---
id: flexible-variables-for-flexible-environments
title: Using Variables for Environment Flexibility
sidebar_label: Variables
description: "In API Fortress, you do not have to be concerned with organizing variables in a hierarchy from global to local."
---

import useBaseUrl from '@docusaurus/useBaseUrl';

In API Fortress, you do not have to be concerned with organizing variables in a hierarchy from global to local… why?

Almost any string can be hardcoded or referenced as a variable in API Fortress. Hardcoding is fine as long as you’re building simple tests, however, it is advisable to parametrize some items when:

- The number of tests is increasing
- The complexity of tests is increasing
- The number of tested environments is increasing

Most of the parametrization you will likely do relates to the HTTP request itself.

## Using the Vault
You can access the vaults in one of two ways:

1. From the Dashboard:
   <img src={useBaseUrl('img/api-fortress/2021/04/fromDashboard.png')} alt="Access Vault from Dashboard"/>

2. From the Project view:
   <img src={useBaseUrl('img/api-fortress/2021/04/vaultFromProject.png')} alt="Access Vault from Project View "/>

Consider this variable:

<img src={useBaseUrl('img/api-fortress/2017/09/harcoded.png')} alt="Hardcoded Variables"/>

While the following variable is perfectly valid, it may become extremely painful to update tens or hundreds of tests if the domain changes.

Alternatively, you may use the API Fortress Vault to store domain names to solve this problem. Simply add a “domain” variable in your vault as follows:

<img src={useBaseUrl('img/api-fortress/2021/04/variableEntry.png')} alt="Domain Variables"/>

And then edit the `GET` request with `${domain}` like this:

<img src={useBaseUrl('img/api-fortress/2017/09/parametrized.png')} alt="Parametrized Variables"/>

You can also set URL endpoints as variables, for example:

<img src={useBaseUrl('img/api-fortress/2021/04/urlVariable.png')} alt="URL Variables"/>

In this way, you can eliminate duplicate tasks by simply editing the vault variable to instantly update all tests based on domains and url changes.

## Using the Environments

Once a domain is parametrized, you may override a variable, if needed.

To access and create new environments:

* Visit the _Environment_ section in the test project section:
  <img src={useBaseUrl('img/api-fortress/2021/04/accessEnvironment.png')} alt="access environment"/>

* Add the details (typically the target domain) and select _Confirm_:
  <img src={useBaseUrl('img/api-fortress/2021/04/createEnvironment.png')} alt="create environment"/>

* Add the variable details and select _Confirm_:
  <img src={useBaseUrl('img/api-fortress/2021/04/addDomainVar.png')} alt="variable in environment"/>

  You can add multiple variables to each environment:
  <img src={useBaseUrl('img/api-fortress/2021/04/result.png')} alt="result in environment"/>

* The resulting environment (along with the defined variables) is now selectable and appears in the environment section:
  <img src={useBaseUrl('img/api-fortress/2021/04/result2.png')} alt="result in tests"/>

By activating a preset in the tests section, you will be able to hit a different domain in the current session without actually changing the tests.

The same selection can be performed while creating a schedule to create specific runs hitting specific environments.

## In Request Bodies

Variables are not only bound to URLs. Request bodies can also be handled like "templates" when needed, incorporating variables as in:

<img src={useBaseUrl('img/api-fortress/2017/09/body.png')} alt="BODY"/>

And Basically Anywhere

Reference variables almost anywhere that you need. Consider the following example assertion:

<img src={useBaseUrl('img/api-fortress/2017/09/exp.png')} alt="EXP"/>

Yes, we're using variables as expected values.

## Conclusion

API Fortress provides the flexibility and freedom to combine the use of global, local, and hard coded variables as you want. In addition, API Fortress also provides helpful hints as you work with variables.

1. Fill the vault with data that is project-centric: Domains, protocols, API keys. They are all fine. We discourage you from introducing test-specific variables because it would produce an overhead of information that would go unused most of the time.
2. Fill the globals/input set with test-specific variables, such as paths, IDs, dates, and serial numbers, etc.
3. Make sure that the “vault + globals/input set” add up to a complete variable scope for the test. In other words, the test should be able to run without further information.
4. Use the environments to change the values of the variable scope generated by the vault+global/input sets.
5. Don’t overdo things. Parametrize stuff that can actually change, and leave everything else as static strings. Variables are… well, variable, so an excessive and unnecessary use of variables leads to uncertainty and hard-to-track behaviors.
